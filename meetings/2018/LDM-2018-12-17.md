
# C# Language Design Meeting for Dec. 17, 2018

## Agenda

1. Review the Nullable Reference Types Specification

## Discussion

### Syntax

We have some new 

#### Simple type reference syntax

Formally add a nullable type syntax that's allowed on reference types.
For simple type declarations this isn't actually determinable during parsing,
so any existing language restriction is incorrect, but it's important to
note that any such existing requirement is no longer valid ever.

There are a few places where this is not allowed, like as a base class or
interface, as the the type in an object_creation_expression, etc.

Follow-up:

- Two question marks
- Work out arrays

#### "Null-forgiving" operator

The `!` operator. We're not sure of the name yet.

Notes:

- `primary_expression` must not be known to be a value type

#### Nullable implicitly typed locals

Allow `var?`

Notes:

- Concern that there's missing symmetry because you can't say `var!`
- We previously discussed this, but aren't sure we want to include it

#### Nullable compiler directives

- The spec has `#safeonly` but we haven't decide if that's the final syntax.
- `enable` is underspecified in the full space of all the possible diagnostic
  configurations that Roslyn can produce, so we should more fully define what
  it means

#### Nullable contexts

Also not fully specified in exactly what diagnostic levels can be produced. Needs
some final review.

#### Nullable types

- This section also needs some work for arrays ("last token" problem).
- There's some conflict with the terminology used in the spec and what we use in
  the compiler. We should attempt to synchronize. 
- When declaring a generic parameter, there are two places the context matters:
  1. The constraint declaration, where the constraints decide warnings for caller
  2. The usage of the parameter

Q: Is this right: "For a type parameter `T`, `T?` is only allowed if `T` is known
to be a value type or known to be a reference type."

#### Principles

1. Where a type is uttered is where the annotation context matters

```C#
#nullable enable
public string s = null; // warning
#nullable disable
public string s = null; // no warning
#nullable enable
s2 = null; // still no warning
public string s3, 
#nullable disable
s4;
#nullable enable
s3 = null  // warning
s4 = null; // warning -- type location that matters
```

2. The annotation context of a type only matters for conversions *to* that type

3. For a given *value*, the annotation context or nullness of its type
   doesn't matter, only whether its null states it may be null

4. Type inference is a convenience to infer a type you could have written,
   and the result should be the same as if the type were written explicitly

```C#
// external: List<string~> L();
T M<T>(T t) => t;
#nullable enable
M(L()); // T is inferred as List<string>, which, since we're in a non-null
        // context, this is List<string!>
```

- This does reduce some forms of expressiveness, but it leans on the idea
  that the user's context decides the nullability and they are responsible
  for proper typing once you enter user code in a non-null context.

5. For type inference, the only input is the *values*

- This may not be correct for ref parameters

6. For an inferred type, its "location" is spec'ed based on where it "would have been"
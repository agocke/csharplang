
# C# Language Design Meeting for Nov. 20, 2019

## Agenda

1. UTF-8 strings
2. More pattern matching

## Discussion

### UTF-8 strings

We previously discussed UTF-8 strings in broad strokes, but didn't have a full proposal to look
at. The main change in the current proposal is that there is no special syntax for Utf8Strings,
but instead we use the existing string literal syntax and make constant strings implicitly
convertible to Utf8String. In addition, Utf8String can have constant values and is subject to
constant folding, including concatenation.

The result is that there would be constant concatenation between Utf8strings that is a built-in
operator. We would also add built-in operators for concatenating constant strings and constant
Utf8Strings.

One of the disadvantages of this circumstance is that whenever you have an overload for both
`string` and `utf8string`, passing a string literal would be ambiguous. You either have to add a
cast, or `string` will always get picked, for backwards compatibility. An alternate syntax for
literals would definitely be a shorter syntax for this problem, at the cost of additional
complexity for what may be a corner case. Notably, this would only happen for string literals,
since variables would already have a type.

There are also some scenarios where we'd like to convert between a literal and a
`ReadOnlySpan<byte>`. For instance, it's common in the runtime to compare against static strings
as bytes, e.g.

```C#
class C
{
    private static readonly ReadOnlySpan<byte> s_header = "HTTP"; // not legal as a UTF-16 string
}
```

There are a couple alternatives here, including 

```C#
class C
{
    private static readonly ReadOnlySpan<byte> s_header = (Utf8String)"HTTP";
}
```

but this is unfortunate because it's not clear to C# users whether the cast `Utf8String` is simply
reinterpreting the data, or whether there's a change in representation.

However, it wouldn't be too hard to construct a helper for this scenario:

```C#
class C
{
    private static readonly ReadOnlySpan<byte> s_header = Utf8String.AsSpan("HTTP");
}
```

On the other hand, if we made a constant conversion to `ReadOnlySpan<byte>`, e.g.

```C#
class C
{
    private static readonly ReadOnlySpan<byte> s_header = "HTTP";
}
```

We agree this would be bad, even if the implementation is safe, simply because there's no mention
of UTF-8 anywhere in the conversion, and we think that's too confusing.

**Conclusion**

There only seem to be a few scenarios where an extra literal syntax would be nice, and right now
we don't think the complexity merits the addition. The proposal is accepted as-is, with no UTF-8
literal syntax.

### More pattern matching

We're wondering if there's a way to extend the pattern matching syntax to allow the relational operators
at the end, i.e. in

```C#
if (o is Type(positional) { properties } name)
```

could we put the relational operators after `name`? Unfortunately not. This causes a collision with existing
code:

```C#
if (o is int x < Z)
```

This is valid code today. However, it's not a likely use case. You would have to have `<` as a user-defined
operator on the Z type, and it would have to take a bool as the first argument.

On the semantic side, it feels a little strange that the `and` and `or` operators don't "learn" from the patterns
on the other side. For instance,

```C#
if (o is long x and <= 100)
```

would actually produce a diagnostic because the pattern can never match. `<= 100` implicitly includes an `int` check
and the previous check is `long`. Both cannot be true. There's some sense that it could be useful to "learn" that
the type of the input is `long` after the left hand and adapt `<= 100` to the narrowed type, but it's also not clear
how that actually works.

**Conclusion**

It feels like we've narrowed the ambiguities in the syntax changes for the relational operators to a narrow area. We
may still need to investigate problems with `not`.

The concept of learning from checks also merits more investigation. It would be useful to know in the following check,

```C#
enum class Bool
{
    True,
    False
}
Bool b;
_ = b switch
{
    True => ...,
    _ => ...
}
```

that the `_` in the switch is actually `false`, because all other possibilities have been exhausted. This area needs more
design.
